import {
  borderRadius,
  fontType,
  getCSSAndLinkGoogleFonts,
  hexToHsl,
  mimeTypes,
} from '@contentql/core'
import { env } from '@env'
import configPromise from '@payload-config'
import type { Metadata, Viewport } from 'next'
import { unstable_cache } from 'next/cache'
import { getPayload } from 'payload'
import { Fragment } from 'react'
import { Toaster } from 'sonner'

import '@/app/(app)/globals.css'
import Provider from '@/trpc/Provider'

const getCachedSiteSettings = unstable_cache(
  async () => {
    const payload = await getPayload({
      config: configPromise,
    })

    const data = await payload.findGlobal({
      slug: 'site-settings',
      draft: false,
    })

    return data
  },
  ['site-settings'],
  { tags: ['site-settings'] },
)

export async function generateMetadata(): Promise<Metadata> {
  try {
    // calling the site-settings to get all the data
    const metadata = await getCachedSiteSettings()
    const generalSettings = metadata?.general

    const ogImageUrl =
      typeof generalSettings?.ogImageUrl === 'object'
        ? generalSettings?.ogImageUrl?.url!
        : '/images/seed/og-image.png'

    const title = {
      default: generalSettings?.title,
      template: `%s | ${generalSettings?.title}`,
    }

    const description = generalSettings?.description
    const ogImage = [
      {
        url: `${ogImageUrl}`,
        height: 630,
        width: 1200,
        alt: `og image`,
      },
    ]

    return {
      title,
      description,
      // we're appending the http|https int the env variable
      metadataBase: env.PAYLOAD_URL as unknown as URL,
      openGraph: {
        title,
        description,
        images: ogImage,
      },
      twitter: {
        title,
        description,
        images: ogImage,
      },
      keywords: generalSettings?.keywords,
    }
  } catch (error) {
    // in error case returning a base metadata object
    console.log({ error })

    return {
      title: 'Create CQL App',
      description: 'Generated by create cql app',
    }
  }
}

export const viewport: Viewport = {
  themeColor: 'dark',
  initialScale: 1,
}

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  const { general, themeSettings } = await getCachedSiteSettings()
  const generalSettings = general
  const { lightMode, darkMode, fonts, radius } = themeSettings

  const faviconUrl =
    typeof generalSettings?.faviconUrl === 'object'
      ? generalSettings?.faviconUrl?.url!
      : '/favicon.ico'

  const displayFont =
    fonts.display.type === 'customFont'
      ? typeof fonts.display.customFont === 'object'
        ? {
            url: fonts.display.customFont?.url ?? '',
            format:
              mimeTypes[
                ((fonts.display?.customFont?.url ?? '').split('.')?.[1] ??
                  'otf') as keyof typeof mimeTypes
              ],
            fontName: 'Display',
          }
        : undefined
      : {
          googleFontURL: fonts.display.remoteFont ?? '',
          fontName: fonts.display.fontName ?? '',
        }

  const bodyFont =
    fonts.body.type === 'customFont'
      ? typeof fonts.body.customFont === 'object'
        ? {
            url: fonts.body.customFont?.url ?? '',
            format:
              mimeTypes[
                ((fonts.body?.customFont?.url ?? '').split('.')?.[1] ??
                  'otf') as keyof typeof mimeTypes
              ],
            fontName: 'Body',
          }
        : undefined
      : {
          googleFontURL: fonts.body.remoteFont ?? '',
          fontName: fonts.body.fontName ?? '',
        }

  const googleFontsList = [
    displayFont?.googleFontURL ?? '',
    bodyFont?.googleFontURL ?? '',
  ].filter(url => Boolean(url))

  const response = await getCSSAndLinkGoogleFonts({
    fontUrlList: googleFontsList,
  })

  return (
    <html
      lang='en'
      style={
        {
          '--background': hexToHsl(lightMode.background),
          '--text': hexToHsl(lightMode.text),
          '--foreground': hexToHsl(lightMode.foreground),
          '--primary': hexToHsl(lightMode.primary),
          '--font-display': `${displayFont?.fontName ?? ''}, sans-serif`,
          '--font-body': `${bodyFont?.fontName ?? ''}, sans-serif`,
          '--border-radius': `${borderRadius[radius]}rem`,
        } as React.CSSProperties & { [key: `--${string}`]: string }
      }>
      <head>
        <link rel='icon' type='image/x-icon' href={faviconUrl} />
        {displayFont?.url && (
          <link
            rel='preload'
            href={`${env.PAYLOAD_URL}${displayFont.url}`}
            as='font'
            type={displayFont.format}
            crossOrigin='anonymous'
          />
        )}

        {bodyFont?.url && (
          <link
            rel='preload'
            href={`${env.PAYLOAD_URL}${bodyFont.url}`}
            as='font'
            type={bodyFont.format}
            crossOrigin='anonymous'
          />
        )}

        <style
          dangerouslySetInnerHTML={{
            __html: `${
              displayFont?.url
                ? `@font-face {
            font-family: 'Display';
            src: url(${env.PAYLOAD_URL}${displayFont.url}) format(${fontType[displayFont.format]});
            font-weight: normal;
            font-style: normal;
            font-display: swap;
          }`
                : ''
            }\n
            ${
              bodyFont?.url
                ? `@font-face {
            font-family: 'Body';
            src: url(${env.PAYLOAD_URL}${bodyFont.url}) format(${fontType[bodyFont.format]});
            font-weight: normal;
            font-style: normal;
            font-display: swap;
          }`
                : ''
            }`,
          }}
        />

        {response.map(({ cssText, preloadLinks }, index) => (
          <Fragment key={index}>
            {preloadLinks.map(({ href, type }) =>
              href ? (
                <link
                  rel='preload'
                  as='font'
                  crossOrigin='anonymous'
                  href={href}
                  type={type}
                  key={href}
                />
              ) : null,
            )}
            <style dangerouslySetInnerHTML={{ __html: cssText }} />
          </Fragment>
        ))}
      </head>

      <body className={`font-body antialiased`}>
        <Provider>{children}</Provider>

        {/* Sonnar toast library */}
        <Toaster richColors theme='dark' />
      </body>
    </html>
  )
}
